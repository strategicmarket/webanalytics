

--------------------------------

TUTORIAL s

---------------------------------

info on react-router-dom and history object

https://medium.com/@pshrmn/a-simple-react-router-v4-tutorial-7f23ff27adf
https://medium.com/@pshrmn/a-little-bit-of-history-f245306f48dd


-----------------

https://www.valentinog.com/blog/socket-io-node-js-react/

creating reactjs with streaming data

ReactJS has been an awesome development in the way we think about data-driven user interfaces. By eschewing the n-way data-binding we see in many other JavaScript frameworks, it provides a simple, unidirectional flow for handling state in client-side code. Whenever the underlying data of your views change, React automatically re-renders your components. As a result, it makes building views with lots of moving parts a cinch.

Such a philosophy works very well with realtime applications, such as chat apps, dashboards, activity streams, where there is lots of incoming data, and therefore state being constantly modified. Pusher’s evented API makes this even more simple to handle. All you need to do is listen for any incoming data – whether on your server or other clients – and set the the component’s underlying state. React will efficiently re-render your component by calculating the diffs in the DOM and applying the changes. This makes it a great fit for realtime apps with high update rates!

// MainView.js

componentWillMount: function() {

  this.pusher = new Pusher('YOUR_APP_KEY');
  this.chatRoom = this.pusher.subscribe('messages');

},

// MainView.js

componentDidMount: function() {

  this.chatRoom.bind('new_message', function(message){
    this.setState({messages: this.state.messages.concat(message)})
  }, this);

},